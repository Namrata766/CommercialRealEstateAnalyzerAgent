# loan_analyzer/generic_visual_tools.py
"""
Generic VisualizationTool for ADK agents.

- Accepts a visual_spec: list of chart specs. Each chart spec defines:
  - id (optional): unique id for chart
  - type: "line" | "bar" | "pie" | "area" | "scatter"
  - title (optional)
  - data: either
      * series: [{"name": "NOI", "x": [...], "y": [...]}, ...]
      * or categories + values: {"categories": [...], "values": [...]}
  - x_label, y_label (optional)
  - size: [width, height] in inches (optional)
  - filename (optional): name to use in GCS (otherwise autogenerated)
  - upload: bool (default True) -> whether to upload to GCS
  - bucket_name (optional) overrides env var
  - expires_seconds (optional) signed url expiry
- Returns a dict with "visuals": list of metadata for each created chart
  each element: {id, name, local_bytes_len, gcs_path?, signed_url?, data_url?}
"""

from google.adk.tools import BaseTool
import os
import io
import uuid
import datetime
import base64
from typing import List, Dict, Any, Optional

class VisualizationTool(BaseTool):
    name = "visualization.generic_create"
    description = (
        "Create simple charts from a visual_spec, optionally upload to GCS, "
        "and return signed URLs or inline base64 data URLs."
    )

    def __init__(self):
        super().__init__(name=self.name, description=self.description)

    def _validate_spec(self, spec: Dict[str, Any]) -> None:
        if "type" not in spec:
            raise ValueError("Each chart spec must include a 'type' field.")
        if "data" not in spec:
            raise ValueError("Each chart spec must include a 'data' field.")

    def _render_chart_png(self, spec: Dict[str, Any]) -> bytes:
        # Lazy import to keep runtime lightweight
        import matplotlib.pyplot as plt
        plt.switch_backend("Agg")

        typ = spec.get("type").lower()
        title = spec.get("title", "")
        size = spec.get("size", [8, 4])
        x_label = spec.get("x_label", "")
        y_label = spec.get("y_label", "")

        fig = plt.figure(figsize=(size[0], size[1]))

        # Series-based format
        series = spec.get("data", {}).get("series")
        if series and isinstance(series, list):
            for s in series:
                x = s.get("x")
                y = s.get("y")
                name = s.get("name")
                if typ in ("line", "area"):
                    plt.plot(x, y, label=name)
                    if typ == "area":
                        plt.fill_between(x, y, alpha=0.2)
                elif typ == "bar":
                    # if multiple series with same x, stack side-by-side
                    plt.bar(x, y, label=name)
                elif typ == "scatter":
                    plt.scatter(x, y, label=name)
            if any(s.get("name") for s in series):
                plt.legend()
        else:
            # categories + values format
            categories = spec.get("data", {}).get("categories")
            values = spec.get("data", {}).get("values")
            if categories and values:
                if typ in ("bar", "pie"):
                    if typ == "bar":
                        plt.bar(categories, values)
                    else:
                        plt.pie(values, labels=categories, autopct="%1.1f%%")
                else:
                    # fallback to line
                    plt.plot(categories, values)

        plt.title(title)
        if x_label:
            plt.xlabel(x_label)
        if y_label:
            plt.ylabel(y_label)
        plt.tight_layout()

        buf = io.BytesIO()
        plt.savefig(buf, format="png")
        plt.close(fig)
        buf.seek(0)
        return buf.read()

    def _upload_to_gcs(self, bytes_data: bytes, filename: str, bucket_name: str):
        from google.cloud import storage
        storage_client = storage.Client()
        bucket = storage_client.bucket(bucket_name)
        blob = bucket.blob(filename)
        blob.upload_from_string(bytes_data, content_type="image/png")
        # Generate signed URL. This uses google-cloud-storage generate_signed_url.
        # Requires properly scoped credentials (service account or key).
        signed_url = blob.generate_signed_url(expiration=datetime.timedelta(seconds=self._expires_seconds))
        return f"gs://{bucket_name}/{filename}", signed_url

    def run(
        self,
        visual_spec: List[Dict[str, Any]],
        bucket_name: Optional[str] = None,
        default_upload: bool = True,
        default_expires_seconds: int = 3600,
        prefix: str = "visuals/",
    ) -> Dict[str, Any]:
        """
        visual_spec: list of chart specifications (see module docstring)
        bucket_name: if provided, uploads will default to this bucket; otherwise uses GCS_BUCKET env var
        default_upload: whether charts should be uploaded by default (per-chart 'upload' can override)
        default_expires_seconds: signed URL expiry in seconds
        prefix: GCS object prefix for auto-generated filenames
        """
        # store for signed url expiry usage in _upload_to_gcs
        self._expires_seconds = default_expires_seconds
        load_dotenv()
        bucket_name = bucket_name or os.environ.get("GCS_BUCKET")
        visuals = []
        for idx, spec in enumerate(visual_spec):
            try:
                self._validate_spec(spec)
            except Exception as e:
                visuals.append({"id": spec.get("id") or f"chart_{idx}", "error": f"invalid spec: {e}"})
                continue

            chart_id = spec.get("id") or f"chart_{uuid.uuid4().hex[:8]}"
            filename = spec.get("filename")
            upload_flag = spec.get("upload", default_upload)

            try:
                png_bytes = self._render_chart_png(spec)
            except Exception as e:
                visuals.append({"id": chart_id, "error": f"render_failed: {e}"})
                continue

            entry = {
                "id": chart_id,
                "name": spec.get("title") or filename or chart_id,
                "local_bytes_len": len(png_bytes),
            }

            # If upload requested and bucket available, upload and provide signed URL
            if upload_flag:
                if not bucket_name:
                    # fallback to inline if no bucket
                    data_url = "data:image/png;base64," + base64.b64encode(png_bytes).decode("ascii")
                    entry["data_url"] = data_url
                    entry["warning"] = "upload requested but no bucket configured; returning inline data_url"
                else:
                    # ensure filename
                    if not filename:
                        filename = f"{prefix}{chart_id}_{uuid.uuid4().hex}.png"
                    try:
                        gcs_path, signed_url = self._upload_to_gcs(png_bytes, filename, bucket_name)
                        entry["gcs_path"] = gcs_path
                        entry["signed_url"] = signed_url
                    except Exception as e:
                        # fallback to inline data url if upload fails
                        entry["error"] = f"upload_failed: {e}"
                        entry["data_url"] = "data:image/png;base64," + base64.b64encode(png_bytes).decode("ascii")
            else:
                # return inline base64 data url
                entry["data_url"] = "data:image/png;base64," + base64.b64encode(png_bytes).decode("ascii")

            visuals.append(entry)

        return {"visuals": visuals}

visualization_tool = VisualizationTool()